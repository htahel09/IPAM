import numpy as np
import matplotlib.pyplot as plt
class IPAM:

    def crop_image(self, image, top=10, bottom= 10 , left= 10 , right = 10):
            """
            The crop_image method crops an input image by removing the specified number of pixels from the top, bottom, left, and right sides of the image.
            It takes the input image as a NumPy array and the values top, bottom, left, and right as parameters which represent the number of pixels to be removed from the respective sides of the image.
            It then creates a new NumPy array cropped_image by removing the specified number of pixels from each side of the input image using NumPy array slicing. Finally, it returns the cropped image as the output.
            """
            cropped_image = image[top:-bottom, left:-right, :]
            return cropped_image

    def flip_upside_down(self, image):
            """
            The flip_upside_down method takes an image as input and returns the same image flipped upside down. It uses the NumPy function np.flipud() to flip the rows of the input image along the vertical axis.
            This function reverses the order of rows in the array, effectively flipping the image vertically. The flipped image is then returned by the method.
            """
            flipped_image = np.flipud(image)
            return flipped_image

     def find_mirror_image(self, image):
            """
            The find_mirror_image() method finds the mirror image of a given image using NumPy's fliplr() function.
            NumPy's fliplr() function is used to flip the image along the vertical axis i.e., the columns of the image are reversed from left to right, effectively creating a mirror image of the original image.
            In other words, the method takes an image as input and returns the mirror image of the input image as output.
            """
            mirror_image = np.fliplr(image)
            return mirror_image

    def grayscale(self, image):
            """
            The grayscale function takes an input image as a NumPy array and returns a grayscale version of that image. The function uses the dot product of the input image with a set of weights [0.2989, 0.5870, 0.1140] to convert the RGB image to grayscale. These weights are used to determine how much weight to assign to each of the red, green, and blue channels when converting to grayscale.
            The dot product of the input image and the weight matrix gives a new image where each pixel value is a weighted average of the R, G, and B values of the corresponding pixel in the original image.
            The resulting grayscale image has only one channel instead of three channels for red, green, and blue.
            """
            grayscale_image = np.dot(image, [0.2989, 0.5870, 0.1140])
            return grayscale_image

    def blur_image(self, image, extent):
            """
            This function takes an image and a value 'extent' as input, and applies Gaussian blurring to the image. The 'extent' parameter controls the extent of the blur effect. The larger the value of extent, the greater the extent of blurring applied to the image.
            The function first calculates the size of the kernel required for blurring based on the value of 'extent'. This is done by multiplying 3 times the extent value and then taking the next odd integer greater than that. This is because Gaussian kernels are usually odd-sized to ensure that they have a center pixel.
            Next, the function creates a 1D Gaussian kernel using the numpy library's 'exp' function. The kernel is generated by taking the exponential of the squared distance between each pixel in the kernel and the center pixel, divided by twice the square of the extent value.
            The kernel is then normalized by dividing each value by the sum of all values in the kernel.
            Then, the function applies the Gaussian kernel in two dimensions to the image using the numpy library's 'convolve' function. It applies the kernel to each row of the image, then applies it to each column of the resulting array. This is done using the numpy library's 'apply_along_axis' function.
            Finally, the blurred image is normalized and converted to an 8-bit unsigned integer format using the numpy library's 'clip' and 'astype' functions, respectively. The normalized image is then returned as the output of the function.
            """
            k_size = int(3 * extent) * 2 + 1
            k = np.exp(-np.arange(k_size)**2 / (2*extent**2))
            k = k / np.sum(k)
            blurred_image = np.apply_along_axis(lambda x: np.convolve(x, k, mode='same'), axis=0, arr=np.apply_along_axis(lambda x: np.convolve(x, k, mode='same'), axis=1, arr=image))
            blurred_image = np.clip(blurred_image, 0, 255).astype(np.uint8) # Add normalization step
            return blurred_image


